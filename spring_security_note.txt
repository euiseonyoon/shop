
https://docs.spring.io/spring-security/reference/servlet/architecture.html의 내용을 다루고 있음

* Servlet: 

client
   |
filter
   |
filter
   |
   .. 
    |
servlet


* Spring의 sevlet 관련 지원:
    - Spring은 `org.springframework.web.filter.DelegatingFilterProxy` 라는 `jakarta.servlet.Filter`의 구현체를 제공한다.

    - DelegatingFilterProxy의 내부에서는 
        Spring의 ApplicationContext내부의 Bean을 필터로 가져다가 사용하게 해준다.

    - Servelt 컨테이너는 해당 `DelegatingFilterProxy`가 `Filter`의 구현체임으로, `Filter`로 인식하고 추가한다. (내부에 어떤게 있는지는 모른다.)


* Spring Security:

    - Spring Security의 Sevlet 지원은 `org.springframework.security.web.FilterChainProxy` 라는것에 구현된다.

    - `DelegatingFilterProxy`는 Spring Security의 `FilterChainProxy`의 구현체 Bean을 프록시한다.

    - `FilterChainProxy` Bean은 다시 여러개의 필터를 연결헤놓은 `org.springframework.security.web.SecurityFilterChain`을 사용한다.
        `FilterChainProxy` 내부에 보면  
        `private List<SecurityFilterChain> filterChains` 라는것이 있다.
        이것이 우리가 만드는 SecurityFilterChain들이 저장되는 곳 같다.
        아래의 코드예시 에서 "여기" 라고 표시 한 것들이 SecurityFilterChain에 포함되는 Filter들 이다.
        해당 Filter들은 대부분 Bean이며, 이 Bean들은 `FilterChainProxy`에 등록된다.


1. `SecurityFilterChain` 설명

@Configuration 
@EnableWebSecurity
class SecurityConfig {
    @Bean 
    fun corsConfigurationSource(): CorsConfigurationSource {
        val config =
            CorsConfiguration().apply {
                allowedOrigins = listOf("*")
                allowedMethods = listOf("*") // 임시로 모든 메소드 허용
                allowedHeaders = listOf("*")
                allowCredentials = true
                maxAge = 3600L
            }
        val source = UrlBasedCorsConfigurationSource()
        source.registerCorsConfiguration("/**", config)
        return source
    }

    @Bean 
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        val result : DefaultSecurityFilterChain = http
            .csrf { it.disable() } // org.springframework.security.web.csrf.CsrfFilter  <-- 여기
            .cors { cors -> cors.configurationSource(corsConfigurationSource()) } // org.springframework.web.filter.CorsFilter   <-- 여기
            .httpBasic {  } // org.springframework.security.web.authentication.www.BasicAuthenticationFilter   <-- 여기
            .formLogin {  } // org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter   <-- 여기
            .build()
        
        return result
    }
}


CsrfFilter - org.springframework.web.filter.OncePerRequestFilter() 상속 - org.springframework.web.filter.GenericFilterBean() 상속 - jakarta.servlet.Filter(인터페이스) 구현
CorsFilter - org.springframework.web.filter.OncePerRequestFilter() 상속 - org.springframework.web.filter.GenericFilterBean() 상속 - jakarta.servlet.Filter(인터페이스) 구현
BasicAuthenticationFilter - org.springframework.web.filter.OncePerRequestFilter() 상속 - org.springframework.web.filter.GenericFilterBean() 상속 - jakarta.servlet.Filter(인터페이스) 구현
UsernamePasswordAuthenticationFilter - org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter() 상속 - org.springframework.web.filter.GenericFilterBean() 상속 - jakarta.servlet.Filter(인터페이스) 구현


한마디로 우리가 Spring Security를 통해서 만드는 필터들이 합쳐져서 `SecurityFilterChain`를 이루고
이 `SecurityFilterChain`(들)은  Spring Security의 `FilterChainProxy`프록시 Bean에 의해 사용되며,
`FilterChainProxy` 프록시 Bean은 다시 Spring의 `DelegatingFilterProxy`프록시에 의해 사용되고
`DelegatingFilterProxy`은 Servlet의 Filter로 작용한다.


Filter를 `SecurityFilterChain`에 추가 할 때에는 아래와 같은 메소드를 사용할 수 있다.
    .addFilterAt()
    .addFilter()
    .addFilterAfter()
    .addFilterBefore()

예시)

@Configuration 
@EnableWebSecurity
class SecurityConfig {
    @Bean 
    fun corsConfigurationSource(): CorsConfigurationSource {
        val config =
            CorsConfiguration().apply {
                allowedOrigins = listOf("*")
                allowedMethods = listOf("*") // 임시로 모든 메소드 허용
                allowedHeaders = listOf("*")
                allowCredentials = true
                maxAge = 3600L
            }
        val source = UrlBasedCorsConfigurationSource()
        source.registerCorsConfiguration("/**", config)
        return source
    }

    @Bean 
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        val result : DefaultSecurityFilterChain = http
            .csrf { it.disable() } // org.springframework.security.web.csrf.CsrfFilter
            .cors { cors -> cors.configurationSource(corsConfigurationSource()) } // org.springframework.web.filter.CorsFilter
            .httpBasic {  } // org.springframework.security.web.authentication.www.BasicAuthenticationFilter
            .formLogin {  } // org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter
            .addFilterBefore(...). <-- 예시
            .build()
        
        return result
    }
}


2. 여러개의 `SecurityFilterChain` 사용
앞선 예제에서는 1개의 SecurityFilterChain에 여러개의 Filter들을 넣어서 사용하는 상황을 보았다.
여기서는 여러개의 SecurityFilterChain을 사용하는 방법을 보자

예시)

@Configuration @EnableWebSecurity
class SecurityConfig {
    @Bean
    fun corsConfigurationSource(): CorsConfigurationSource {
        val config =
            CorsConfiguration().apply {
                allowedOrigins = listOf("*")
                allowedMethods = listOf("*") // 임시로 모든 메소드 허용
                allowedHeaders = listOf("*")
                allowCredentials = true
                maxAge = 3600L
            }
        val source = UrlBasedCorsConfigurationSource()
        source.registerCorsConfiguration("/**", config)
        return source
    }

    private fun makeBaseHttpSecurity(http: HttpSecurity): HttpSecurity {
        val httpSecurity: HttpSecurity = http
            .securityMatcher("some condition")
            .csrf { it.disable() }
            .cors { cors -> cors.configurationSource(corsConfigurationSource()) }
            
        return httpSecurity
    }

    @Bean 
    @Order(1)
    fun formLogInSecurityFilterChain(http: HttpSecurity): SecurityFilterChain {
        val formLoginSecurityFilterChain = makeBaseHttpSecurity(http)
            .securityMatcher("/login/form")
            .formLogin {  }
            .build()
        return formLoginSecurityFilterChain
    }

    @Bean 
    @Order(2)
    fun basicSecurityFilterChain(http: HttpSecurity): SecurityFilterChain {
        val basicSecurityFilterChain = makeBaseHttpSecurity(http).build()
        return basicSecurityFilterChain
    }
}

SecurityFilterChain1 : 
    이름 : formLogInSecurityFilterChain
    filters : CSRF 필터, CORS 필터, FORM LOGIN 필터 

SecurityFilterChain2 : 
    이름 : basicSecurityFilterChain
    filters : CSRF 필터, CORS 필터

이렇게 여러개의 SecurityFilterChain을 만들수 있다.
이런 다수의 SecurityFilterChain은  FilterChainProxy의 내부에 등록된다.
그러면 어떤 상황에서 어떤 SecurityFilterChain을 사용해야 하는지는 어떻게 조정할 수 있을까?
답은 Ordering + `securityMatcher()`에 있다.

1. @Order가 낮은 순데로, 여러 SecurityFilterChain들을 "검사"한다.
2. 1번에서 "검사"라는 과정은, 특정 SecurityFilterChain에 명시된 메소드 securityMatcher( some condition )를 확인,
현재 시나리오가 "some condition" 과 일치한다면, 해당 SecurityFilterChain을 적용하게 된다.
3. 만약 Order1, Order2,... 의 SecurityFilterChain의 securityMatcher() 조건에 모두 부합하지 않는다면,
최종적으로 마지막 Order를 가진 SecurityFilterChain까지 오게 된다. 이때 만약 마지막 SecurityFilterChain에 securityMatcher()가 있고,
그 조건 마저 충족시키지 못한다면, 어떠한 SecurityFilterChain도 적용되지 않는다.

pseudo code

val securityFilterChainsInOrder = @Order가 낮은 순데로 정렬된 SecurityFilterChain Bean들
val securityFilterChainToUse = null
for (securityFilterChain in securityFilterChainsInOrder) {
    if (current situation matches securityFilterChain.securityMatcher()에 명시된 condition) {
        securityFilterChainToUse = securityFilterChain
    }
}
if (securityFilterChainToUse != null) {
    securityFilterChainToUse을 적용하여 필터링
} else {
    어떠한 SecurityFilterChain 도 적용하지 않음 (필터링 없음)
}


3. org.springframework.security.web.access.ExceptionTranslationFilter

`ExceptionTranslationFilter` 필터가 어떤 SecurityFilterChain에 포함된다면,
그 SecurityFilterChain의 필터들을 수행중에  
    org.springframework.security.access.AccessDeniedException 
    org.springframework.security.access.AuthenticationException
이 발생한다면, 이들을 "처리" 한다.
여기서 "처리"는 Authentication 과정을 시작 하는것이다.
그래서  ExceptionTranslationFilter의 생성자에는 `org.springframework.security.web.AuthenticationEntryPoint`가 필수로 필요하다.
자세한건 ExceptionTranslationFilter의.doFilter(private 메소드)를 보면 알 수 있다.

ExceptionTranslationFilter는

HttpSecurity.build()를 하면 자동적으로 추가된다. 
예)
@Bean 
@Order(1)
fun formLogInSecurityFilterChain(http: HttpSecurity): SecurityFilterChain {
    val formLoginSecurityFilterChain = makeBaseHttpSecurity(http)
        .securityMatcher("/login/form")
        .formLogin {  }
        .build() <-- 여기서 자동 추가됨
    return formLoginSecurityFilterChain
}

만약 자동으로 추가하는 것을 원하지 않는다면 HttpSecurity에 .exceptionHandling 메소드를 사용하여 헨들링 할 수 있다.
다만, 이런 경우  사용자를 로그인 페이지로 리디렉팅하거나  401(Unahtorized)를 보내는 자동적인 흐름이 작동하지 않을 수 있다.
예)

@Bean @Order(1)
fun formLogInSecurityFilterChain(http: HttpSecurity): SecurityFilterChain {
    val formLoginSecurityFilterChain = makeBaseHttpSecurity(http)
        .securityMatcher("/login/form")
        .formLogin {  }
        .exceptionHandling {  } <-- 여기
        .build()
    return formLoginSecurityFilterChain
}

질문:
    HttpSecurity.build()를 하면 
    자동적으로 ExceptionTranslationFilter가 SecurityFilterChain에 등록된다고 했잖아
    근데 ExceptionTranslationFilter의 생성자를 보니 AthenticationEntryPoint가 필수던데
    자동으로 등록되는 ExceptionTranslationFilter에는 어떤 AuthenticationEntryPoint가 들어가는거니?

답변: 
    어떤 AuthenticationEntryPoint가 주입되는지는 주로 HttpSecurity에서 어떤 인증 메커니즘을 활성화했는지에 따라 달라집니다.

    가장 일반적인 경우는 다음과 같습니다:

    1. http.formLogin()을 활성화한 경우:

        `LoginUrlAuthenticationEntryPoint`가 자동으로 구성됩니다.
        이 EntryPoint는 인증되지 않은 사용자를 기본 로그인 페이지(기본값 /login)로 리다이렉션합니다.

    2. http.httpBasic()을 활성화한 경우:

        `BasicAuthenticationEntryPoint`가 자동으로 구성됩니다.
        이 EntryPoint는 401 Unauthorized 응답과 함께 WWW-Authenticate: Basic 헤더를 전송하여 브라우저에 기본 인증 대화 상자를 띄우도록 합니다.

    3. http.oauth2Login()을 활성화한 경우:

        `OAuth2LoginAuthenticationEntryPoint`와 같은 OAuth 2.0 로그인 관련 EntryPoint가 구성됩니다.

    4. http.oauth2ResourceServer() (JWT 등 토큰 기반)을 활성화한 경우:

        `BearerTokenAuthenticationEntryPoint`와 같은 토큰 기반 인증용 EntryPoint가 구성됩니다.

    5. 특별한 인증 메커니즘을 명시적으로 활성화하지 않은 경우 (기본값):

        만약 formLogin(), httpBasic() 등을 명시적으로 호출하지 않았다면, 
        Spring Security는 컨텍스트에 따라 HttpStatusEntryPoint (예: 401 Unauthorized 상태 코드 반환)와 같은 
        일반적인 EntryPoint를 기본값으로 사용할 수 있습니다. 웹 애플리케이션에서는 종종 폼 로그인이 기본으로 암시되기도 합니다.


===================================================
Authentication

위의 SecurityFilterChain에 등록된 필터중  `AbstractAuthenticationProcessingFilter`상속 받은 필터가 있다면
이건 Authentication을 위한 필터임을 알고 Authentication을 시작한다.
    좀 더 정확히 말하자면 여느 다른 필터와 같이 doFilter()가 수행된다.
    `AbstractAuthenticationProcessingFilter.doFilter()`내부에서 attemptAuthentication()를 수행한다

(아래 인증 과정은 위에서 언급한 AbstractAuthenticationProcessingFilter.attemptAuthentication()의 과정이다)
이 인증 과정 아래와 같다.
1. 필터는 Authentication 이라는 정보를 만든다 ( 인증할때 사용될 유저의 정보 예를들면, 유저의 id(username) 그리고 password)
    `AuthenticationConverter`를 사용하여 request를 Authentication이라는 유저의 정보가 담긴 객체로 만든다.
    참고: AbstractAuthenticationProcessingFilter.authenticationConverter

2. 필터는 만들어진 Authentication을 AuthenticationManager(인터페이스) 에게 전달한다.
    - 유저의 username, password를 정보를 인증에서 사용할때에는, `UsernamePasswordAuthenticationToken`라는 `Authentication` 구현체를 사용한다.

3. 필터가 AuthenticationManager.authenticate()라는 메소드를 호출하며 인증이 시작된다.

3. AuthenticationManager(인터페이스)는 여러개의 AuthenticationProvider(인터페이스)들을 가지고 있다.
    - AuthenticationManager를 구현한 구현체중 ProviderManager가 있다.

4. 해당 AuthenticationManager는 자신이 가지고 있는 여러개의 AuthenticationProvider들의 `authenticate()`라는 메소드를 호출하여 해당 유저(Authentication에 담긴)가 인증이 되는지 검사 한다.
    - AuthenticationProvider를 구현한 구현체중 `DaoAuthenticationProvider`가 있다.

5. 각각의 AuthenticationProvider는 UserDetailService 라는 유저의 정보를 가져오는 서비스를 사용한다.
   해당 서비스는 유저의 정보를 DB로 부터 가져올 수 도 있고, 그렇지 않으면 예를들어 google oauth를 사용해서 유저의 정보를 가져올 수 도 있다,

6. AuthenticationManager가 인증을 마치었다.
    6.1 인증 성공
        AbstractAuthenticationProcessingFilter.successfulAuthentication() 가 호출된다. 아래는 그 내용을 요약한것이다.
        1. 성공하면, Spring Security는 해당 사용자의 SecurityContext를 유저정보(Authentication)를 통해 생성 -> `SecurityContextHolder`에게 SecurityContext를 넘겨줌
        2. SecurityContextHolder는 이걸 현재 요청을 처리하는 스레드의 ThreadLocal에 저장한다.
        3. 어떠한 스레드에서도 SecurityContextHolder.getContext()를 호출하면 해당 스레드에 저장된 SecurityContext를 가져올수 있다.
    6.2 인증 실패
        AbstractAuthenticationProcessingFilter.unsuccessfulAuthentication() 가 호출된다.

================================================================================================
Authorization (인가) - Architecture

1. Authorities(권한)

Authentication(인증)의 과정에서 GrantedAuthority를 유저정보(Authentication)에 기입함
`GrantedAuthority`인터페이스는 getAuthority()라는 메소드가 있음
이 메소드는 `AuthorizationManager`에 의해 주로 사용됨
부여된권한(GrantedAuthority)가 간단한 경우 그냥 String으로 표현하여 AuthorizationManager가 쉽게 read 하고 핸들링 할 수 있음
하지만 부여된권(GrantedAuthority) 복잡한 경우에는 getAuthority() 메소드의 return값이 null이 되어야함
GrantedAuthority.getAuthority()의 결과값이 null -> AuthorizationManager가 "특별한" GrantedAuthority 핸들링이 필요함을 파악

`SimpleGrantedAuthority`는 `GrantedAuthority`의 구현체 중 하나임.
이건 유저의 권한을 String 형태로 저장, "ROLE_" 이라는 prefix를 기본적으로 사용
이 prefix를 바꾸고 싶으면 `GrantedAuthorityDefaults`를 사용할 수 있음


2. Invocation Handling

Spring Security는 method 실행이나, web request에 대해 접근제어를 하는 interceptor를 제공한다
`AuthorizationManager` 객체는 어떤 method가 실행되기전에 어떤 pre-invocation이 이루어질지를 결정하기도하고
어떤 값이 return 되기 전에 post-invocation이 이루어 질지를 결정하기도 한다.

    2.1 AuthenticationManager
        AuthenticationManager는 예전에 사용되었던 legacy인 `AccessDecisionManager`, `AccessDecisionVoter`를 대체한다.
        AuthenticationManager의 여러 구현체들은 Spring Security의 request-based, method-based, message-based 인가요소(authorization components)들에 의해 호출되며,
        최종 접근제어를 한다.

    2.2 Delegate-based AuthorizationManager Implementations
        아래와 같은 Delegating을 하여 secure source에 접근제어를 하는 `AuthorizationManager`의 구현체가 있다. (이외에도 많음)

        RequestMatcherDelegatingAuthorizationManager (secure source가 request base)
        AuthorizationManagerBeforeMethodInterceptor (secure source가 method base)
        AuthorizationManagerAfterMethodInterceptor (secure source가 method base)

        AuthorityAuthorizationManager
            가장 많이 쓰임. 유저정보(Authentication)에 기입된 GrantedAuthority들을 확인하여 접근제어한다.
            (It is configured with a given set of authorities to look for on the current Authentication.)

        AuthenticatedAuthorizationManager
            it can be used to differentiate between anonymous, fully-authenticated and remember-me authenticated users.

        AuthorizationManagers ( AuthorizationManager관련 유용한게 사용될 수 있는 static 메서드들이 많이 있다)

3. Adapting AccessDecisionManager and AccessDecisionVoters (이건 skip)

4. Hierarchical Roles
아래의 코드처럼 Role 간의 Hierarchy를 만들어 낼 수 있다.
위의 롤 상하관계는
    request-based 인가: HttpSecurity.authorizeHttpRequests 에서 사용될 수 있고
    method-based 인가 에서 사용될 수 있다:
        `DefaultMethodSecurityExpressionHandler` for pre-post annotations(@PreAuthorize, @PostAuthorize, @PreFilter @PostFilter),
            예시 1을 참고 : MethodSecurityExpressionHandler 빈을 따로 등록해줘야 한다.

        `SecuredAuthorizationManager` for @Secured 어노테이션,
            예시 2을 참고:
                @EnableMethodSecurity(securedEnabled = true) 추가하고
                @Secure(ROLE_ADMIN) 이런식으로 사용하면 된다.

        `Jsr250AuthorizationManager` for JSR-250 annotations(@RolesAllowed, @PermitAll, @DenyAll.)
            예시 3을 참고:
                @EnableMethodSecurity(jsr250Enabled = true)
                @RolesAllowed, @PermitAll, @DenyAll 등을 사용


// 예시 1.
```
@Bean
static RoleHierarchy roleHierarchy() {
    return RoleHierarchyImpl.withDefaultRolePrefix()
        .role("ADMIN").implies("STAFF")
        .role("STAFF").implies("USER")
        .role("USER").implies("GUEST")
        .build();
}
// @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter 와 같은 pre-post 어노테이션을 사용할때 아래 코드를 추가.
@Bean
static MethodSecurityExpressionHandler methodSecurityExpressionHandler(RoleHierarchy roleHierarchy) {
    DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
    expressionHandler.setRoleHierarchy(roleHierarchy);
    return expressionHandler;
}
```

// 예시 2
```
@Configuration
@EnableMethodSecurity(securedEnabled = true) // @Secured 어노테이션 활성화 (기본값은 false)
class SecurityConfig {

    @Bean
    fun roleHierarchy(): RoleHierarchy {
        val roleHierarchy = RoleHierarchyImpl()
        // 계층 관계 정의: ADMIN은 STAFF의 권한을, STAFF는 USER의 권한을 포함
        roleHierarchy.setHierarchy("ROLE_ADMIN > ROLE_STAFF \n ROLE_STAFF > ROLE_USER")
        return roleHierarchy
    }

    // DefaultMethodSecurityExpressionHandler (pre-post용)는 필요하다면 계속 정의
    // @Bean
    // fun methodSecurityExpressionHandler(roleHierarchy: RoleHierarchy): MethodSecurityExpressionHandler {
    //     val expressionHandler = DefaultMethodSecurityExpressionHandler()
    //     expressionHandler.setRoleHierarchy(roleHierarchy)
    //     return expressionHandler
    // }
}

@Service
class AdminService {
    @Secured("ROLE_ADMIN") // ADMIN 권한이 있는 사용자만 접근 가능
    fun deleteCriticalData() {
        println("Critical data deleted by Admin.")
    }

    @Secured("ROLE_USER") // USER 권한이 있는 사용자만 접근 가능 (ADMIN, STAFF도 가능)
    fun viewUserSpecificData() {
        println("User specific data viewed.")
    }
}
```

// 예시 3
```
@Configuration
@EnableMethodSecurity(jsr250Enabled = true) // JSR-250 어노테이션 활성화 (기본값은 false)
class SecurityConfig {

    @Bean
    fun roleHierarchy(): RoleHierarchy {
        val roleHierarchy = RoleHierarchyImpl()
        // 계층 관계 정의: ADMIN은 STAFF의 권한을, STAFF는 USER의 권한을 포함
        roleHierarchy.setHierarchy("ROLE_ADMIN > ROLE_STAFF \n ROLE_STAFF > ROLE_USER")
        return roleHierarchy
    }

    // ... 나머지 SecurityFilterChain 및 다른 빈들 ...
}

@Service
class ReportService {

    // ADMIN 권한이 있는 사용자만 접근 가능 (RoleHierarchy 적용)
    // 복수의 role도 가능
    @RolesAllowed({"ROLE_ADMIN", "ROLE_SECOND_ADMIN"})
    fun generateDetailedReport() {
        println("Detailed report generated by Admin.")
    }

    @RolesAllowed("ROLE_USER") // USER 권한이 있는 사용자만 접근 가능 (ADMIN, STAFF도 RoleHierarchy에 의해 가능)
    fun viewBasicReport() {
        println("Basic report viewed by user.")
    }

    @PermitAll // 모든 사용자 접근 허용
    fun getPublicReportInfo(): String {
        return "This is public report information."
    }

    @DenyAll // 아무도 접근 불가
    fun restrictedMethod() {
        println("This method should never be called.")
    }
}
```
================================================================================================
Authorization (인가) - Authorize Http Request

1. 동작 flow
    1. SecurityFilterChain에 AuthorizationFilter
        `AuthorizationFilter`는 기본적으로 SecurityFilterChain에서 마지막에 위치한다.
    2. SecurityContextHolder를 사용하여 유저정보(Authentication) 확보
    3. `RequestMatcherDelegatingAuthorizationManager` 가 Authorize 체크

2. https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html#match-requests 에 기입되어 있듯이,
다양한 방식으로 Http Request에 Matching 하게 하여 Authorization을 할 수 있다.


================================================================================================
Authorization (인가) - Method based Security

1. 아래의 경우에 Method based Security를 적용하면 효율적
    - 좀 더 세밀한 Authorization 로직이 필요한 경우, 예를들면, 메소드의 파라미터나 return 결과값을 사용하여 authorization을 해야하는 경우
    - Security를 서비스 layer에서 강제하려 할 때
    - Http-based 보다 어노테이션 기반의 Authorization을 선호 할 때,
(참고로 Method Security는 Spring의 AOP 프록시를 사용한다)


```
@Service
open class MyCustomerService {
    @PreAuthorize("hasAuthority('permission:read')")
    @PostAuthorize("returnObject.owner == authentication.name")
    fun readCustomer(id: String): Customer { ... }
}
```
위 코드를 예시로 사용한다.

2. 동작 Flow

    1. Spring AOP가 readCustomer() 메소드를 invoke 한다.
    proxy의 advisor 중에, @PreAuthorize 포인트컷에 매칭되는 (아마 내부적으로 @annotation을 사용해서 포인트컷을 사용하겟지?)
    `AuthorizationManagerBeforeMethodInterceptor` advisor를 invoke한다.

    2. AuthorizationManagerBeforeMethodInterceptor.invoke()
    -> AuthorizationManagerBeforeMethodInterceptor.attemptAuthorization()
    -> AuthorizationManagerBeforeMethodInterceptor.authorizationManager.authorize()
        AuthorizationManagerBeforeMethodInterceptor.authorizationManager는 `PreAuthorizeAuthorizationManager` 이라는 클래스 타입
        `public final class PreAuthorizeAuthorizationManager implements AuthorizationManager<MethodInvocation>, MethodAuthorizationDeniedHandler {..}`
    -> PreAuthorizeAuthorizationManager.authorize() -> PreAuthorizeAuthorizationManager.check()  호출

    3. AuthorizationManager(PreAuthorizeAuthorizationManager)는 MethodSecurityExpressionHandler를 이용하여 EvaluationContext를 생성
    4. EvaluationContext 생성, 생성된 context 와 유저정보(Authentication)을 비교하여 `permission:read` 권한을 확인
    5. evalution이 통과되면 `readCustomer()` 메소드를 invoke
    6. 통과 안되면, AccessDeniedException 발생
    7. readCustomer() 메소드가 return 하면,
        @PostAuthorize 포인트컷에 매칭되는 어드바이저인 `AuthorizationManagerAfterMethodInterceptor`를 invoke
    8. AuthorizationManagerAfterMethodInterceptor.invoke() ->
        `readCustomer()` 메소드를 invoke ->
        AuthorizationManagerAfterMethodInterceptor.attemptAuthorization() ->
        AuthorizationManagerAfterMethodInterceptor.authorizationManager.authorize()
            AuthorizationManagerBeforeMethodInterceptor.authorizationManager는 `PostAuthorizeAuthorizationManager` 이라는 클래스 타입
            `public final class PostAuthorizeAuthorizationManager implements AuthorizationManager<MethodInvocation>, MethodAuthorizationDeniedHandler {..}`
        PostAuthorizeAuthorizationManager.authorize() ->
        PostAuthorizeAuthorizationManager.check() 호출
     9. EvaluationContext 생성, 생성된 context 와 `returnObject.owner == authentication.name` 확인
     10. evaluation 통과 되면 continue
     11. 그렇지 않으면 AccessDeniedException 발생


    * 위의 예시 처럼 메스드에 여러 어노테이션이 있으면 순차적으로 진행된다
    * 같은 어노테이션은 반복되어 사용될 수 없다
    * 각 어노테이션들은 고유의 포인트컷과 method interceptor(어드바이저 내용을 포함하는)로 이루어 진다

    @PreAuthorize :  AuthorizationManagerBeforeMethodInterceptor 인터셉터의 preAuthorize()를 사용한다, preAuthorize()는 내부적으로 PreAuthorizeAuthorizationManager 를 사용한다
    @PostAuthorize :  AuthorizationManagerAfterMethodInterceptor 인터셉터의 postAuthorize()를 사용한다, postAuthorize()는 내부적으로 PostAuthorizeAuthorizationManager 를 사용한다
    @PreFilter: PreFilterAuthorizationMethodInterceptor 인터셉터를 사용
    @PostFilter: PostFilterAuthorizationMethodInterceptor 인터셉터를 사용
    @Secured:  AuthorizationManagerBeforeMethodInterceptor 인터셉터의 secured()를 사용한다. secured()는 내부적으로 SecuredAuthorizationManager를 사용한다.
    JSR-250 어노테이션: AuthorizationManagerBeforeMethodInterceptor 인터셉터의 jsr250() 사용한다, jsr250()은 내부적으로 Jsr250AuthorizationManager를 사용한다.


* Authorize 어노테이션 (@PreAuthorize, @PostAuthorize):
  목적: 메서드 호출 전체 또는 메서드의 전체 반환 값에 대한 접근 권한을 결정합니다.
  권한이 있다면 메서드가 정상적으로 실행되거나 반환됩니다.

* Filter 어노테이션 (@PreFilter, @PostFilter)
    목적: 메서드의 입력/출력 컬렉션 또는 배열의 개별 요소에 대해 보안 검사를 수행하여,
    허용되지 않는 요소를 제거합니다. 즉, 컬렉션의 "부분 집합"을 제어합니다.
    필터링된 요소는 제거될 뿐, 전체 메서드 호출이 거부되지는 않습니다.

* 아래처럼 사용할 수도 있다.
```
@Target(ElementType.METHOD, ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("hasRole('ADMIN')")
annotation class IsAdmin

@Component
open class BankService {
	@IsAdmin
	fun readAccount(id: Long): Account {
        // ... is only returned if the `Account` belongs to the logged in user
	}
}
```

